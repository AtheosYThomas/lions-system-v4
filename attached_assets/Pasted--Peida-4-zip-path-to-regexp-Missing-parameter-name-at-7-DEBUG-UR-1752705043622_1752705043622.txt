了解，我會深入分析你提供的最新專案（Peida (4).zip），針對 `path-to-regexp` 報錯中出現的 `Missing parameter name at 7: ${DEBUG_URL}`，調查其根本成因與修正建議。

我會檢查整個程式碼中是否有錯誤的模板字串 `${}`、動態 URL 參數、dotenv 取值錯誤、以及與 Express/React Router 路由設定相關的異常。

我完成分析後會提供一份完整說明與修復建議。請稍候片刻。🔍


# 專案路由錯誤分析報告

## 問題概述與錯誤訊息

在最新的 Peida 專案中啟動伺服器時，Express 發生路由解析錯誤，錯誤訊息為：

```
TypeError: Missing parameter name at 7: ${DEBUG_URL}
```

此錯誤來自路由字串解析套件 **path-to-regexp**，表示路由定義中出現了非法的參數佔位符 `${...}`，導致在第7個字元處缺少參數名稱。經深入分析，問題源自不當的路由字串定義以及環境變數插值處理錯誤。

## 不合法的路由定義 (`:param(*)` 模式)

專案過去版本的 `src/index.ts` 檔案中出現了一個非法路由定義，其使用了過時且不支援的萬用字元參數寫法。例如：

```typescript
// 位於 src/index.ts 第95行（舊版代碼）
app.get('/form/:path(*)', (req, res) => {
  res.sendFile(path.join(__dirname, '../client/dist/index.html'));
});
```

上述路由試圖捕捉 `/form/...` 後續所有子路徑，但使用了 `:path(*)` 這種正則風格的寫法。**Express 4+ 不支援在路由參數中直接使用 `(*)`**；`path-to-regexp` 在解析該路由時會誤判有一個未命名的參數，因而拋出 “Missing parameter name” 錯誤。正確的作法是使用星號萬用路徑或明確的參數名稱，例如：

* **使用星號萬用字元：** 將路由定義改為 `/form/*`，讓 `*` 自動匹配任意後續字串。這種寫法符合 Express 語法，可正確捕捉 `/form/` 下所有路徑。
* **使用具名參數：** 若需要參數，可使用類似 `/form/:subPath*`（新的 path-to-regexp 語法）或拆分路由層級。比如先定義 `app.use('/form', formRouter)`，再在子路由中用 `router.get('*', ...)`。

在最新版程式中，`/form/:path(*)` 已移除。但開發人員需注意**避免出現類似 `:param(*)` 不合法模式**。一旦有此類定義，應立即修改為上述安全替代寫法，以防止 path-to-regexp 解析錯誤。

## 未展開的模板字串 (`${...}`) 用於路由

造成 `${DEBUG_URL}` 錯誤的根本原因，是**路由字串中出現了未展開的模板佔位符**。具體而言，專案將環境變數 `DEBUG_URL` 用於路由定義或相關 URL 配置時，沒有正確展開其值，導致字串中殘留了 `${DEBUG_URL}` 字樣。Path-to-regexp 將 `{` 解讀為參數起始，但遇到不符規則的字元（如 `$` 或沒有命名），遂拋出「缺少參數名稱」錯誤。可能的問題代碼例如：

```typescript
// 錯誤範例：直接在路由中使用模板字面值，未展開 DEBUG_URL
app.use('${DEBUG_URL}', someRouter);  // ⚠️ 路由字串包含未展開的 ${DEBUG_URL}
```

上述錯誤示範中，假設 `DEBUG_URL` 環境變數的值為 `http://localhost:5000`。在字符串中未展開時，實際路由變成了 `'${DEBUG_URL}'`，**包含大括號與美元符號的字面字串**。Path-to-regexp 在解析時看到路由包含 `http:`（有冒號但無有效參數名）以及 `${...}`，因此報錯指出第7個字元（索引從0開始）處出現非法參數格式。

經查詢專案程式碼，`DEBUG_URL` 環境變數主要用於偵錯伺服器及系統診斷，正常情況下不應直接出現在 Express 主應用的路由中。顯示 `DEBUG_URL` 只是被用來在偵錯介面輸出環境變數值。然而，如果在程式某處（例如路由設定或 URL 重寫設定）錯誤地將 `process.env.DEBUG_URL` 當作路由前綴使用，就會產生上述錯誤。例如，開發者可能試圖將主應用掛載在特定 base URL：

```typescript
// 假設的錯誤用法：以環境變數作為路由前綴
const basePath = process.env.DEBUG_URL;       // DEBUG_URL="http://localhost:5000"
app.use(basePath, mainRouter);               // ⚠️ 將包含 "http://" 的字串當作路徑
```

以上代碼會令 Express 嘗試解析 `'http://localhost:5000'` 作為路由路徑。**Express 路由不允許直接使用完整URL**；`http://`中的冒號和後續符號並非合法的路徑模式，導致解析失敗。正確的作法應該是：

* **使用相對路徑前綴：** 如果希望設定應用的 base path，環境變數應僅提供路徑部分。例如 `BASE_PATH="/api/v1"`，然後 `app.use(process.env.BASE_PATH || '/', mainRouter)`. 如此不會含有協議(`http://`)或未展開的佔位符。
* **用變數構造完整URL而非路由：** 若 `DEBUG_URL` 代表完整主機 URL，只應在需要拼接出URL字串時使用，例如前端或文件中引用，**不要在 `app.use`/`app.get` 內直接使用**。Express 的路由定義只接受路徑 (如 `/api`)，不可包含協議或主機。顯示專案在偵錯介面正確地將 `DEBUG_URL` 作為普通字串輸出，類似方式也適用於後端需要組裝URL的情境。

## 環境變數 `.env` 設定檢查

檢視專案提供的 `.env` 檔案內容，確認 `DEBUG_URL` 環境變數有正確設定：

```bash
# Peida/.env（節錄）
DEBUG_URL=http://localhost:5000
```

專案的 `.env` 檔案中已明確定義了 `DEBUG_URL`【49†】。因此，可以排除因 `.env` 缺少該變數而導致字串不完整的情況。然而，需要注意：**dotenv 不會自動展開值中的變數佔位符**。例如，若 `.env` 檔寫成 `API_URL=${DEBUG_URL}/api`，在未搭配額外套件的情況下，讀入時會原樣保留`${DEBUG_URL}`字串而不會替換。【49†】中的設定並未出現此問題，但開發者應避免在 `.env` 中使用未定義的變數作為值的一部分。如果一定需要在 `.env` 中引用其他變數，建議使用 **dotenv-expand** 等套件來處理變數展開，否則會將諸如 `${DEBUG_URL}` 當成純文字讀入，進而引發路由解析錯誤。

另外，診斷報告顯示 `.env` 中某些變數重複定義的警告（如 `PORT`、`NODE_ENV` 等）。雖然這與此次錯誤無直接關聯，但仍建議整理 `.env`，移除重複項以免混淆。特別是 `DEBUG_URL` **應確保僅定義一次且格式完整**（包含協議與正確的主機位址），以供程式正確使用。

## 套件載入與 URL 重寫設定檢查

經檢閱，專案並未使用特殊的 webpack、Vite 或中介軟體來對請求 URL 進行重寫或代理，因此不存在此方面將未展開變數插入路徑的情形。前端 Vite 設定檔 `vite.config.ts` 相當簡單，沒有使用 `DEBUG_URL` 進行 proxy 配置或全域替換【27†】。同時，React Router 前端路由定義均為靜態字串（例如 `/checkin/:eventId?`），未發現包含 `${}` 的異常路由模式【48†】。因此，可以排除前端路由直接導致該錯誤的可能。

值得一提的是，如果將來需要在開發伺服器中代理 API 請求到後端（例如使用 Vite 的 `proxy` 選項或 http-proxy-middleware 中介層），**切勿**直接在設定中使用 `"${DEBUG_URL}"` 字樣。應該在配置時就引用變數的值，例如：

```javascript
// Vite 開發伺服器代理設定（示例）
proxy: {
  '/api': {
    target: process.env.DEBUG_URL || 'http://localhost:5000',
    changeOrigin: true
  }
}
```

上述配置中，`process.env.DEBUG_URL` 會被 Node 在執行時展開為實際字串，如 `http://localhost:5000`，而不會將未展開的占位符留到路由解析階段。這樣可避免類似的 path-to-regexp 錯誤。

## 結論與修正建議

綜合上述分析，**路由定義中的非法模式與未展開的模板字串**是導致 `path-to-regexp` 報錯的根本原因。為解決問題，建議採取以下措施：

1. **修正非法路由模式：** 確認所有 Express 路由定義中沒有使用過時的萬用字元寫法。例如，將先前的 `/form/:path(*)` 改為 `/form/*` 或其他正規寫法。在目前版本中，`/form` 路由已移除，但務必在未來避免使用任何包含 `(*)` 或類似非法片段的路由。

2. **避免在路由中直接使用 `${...}`：** 檢查 `src/index.ts` 及相關檔案中，是否有使用類似 `app.use('${DEBUG_URL}', ...)` 或 `app.get(\`\${someVar}\`, ...)`的片段。若有，應改為使用實際路徑片段或變數值。例如，如果希望在開發模式下讓後端接受特定前綴，應將`\${DEBUG\_URL}`的值（例如`/dev\`）提取為變數，然後正常串接路徑。例如：

   ```typescript
   const debugPath = process.env.DEBUG_PATH || '/';  
   app.use(debugPath, router);  // 使用‘/’或'/dev'等合法路徑
   ```

   切勿包含整個 URL 或未展開的占位符在路由字串中。

3. **確認環境變數載入順序：** 確保在使用 `process.env.DEBUG_URL` 之前，已經正確呼叫 `dotenv.config()` 並載入 `.env`。 本專案的 `src/config/config.ts` 已在頂部調用了 `dotenv.config()`，環境變數理應正確載入。然而，多確認一遍變數值是否如預期（例如透過在啟動時 `console.log(process.env.DEBUG_URL)`)，以排除變數未定義導致的 `${DEBUG_URL}` 殘留情形。若發現變數未定義，應檢查 `.env` 檔名（在開發環境下需為 `.env` 而非 `.env.example`）、變數拼寫，以及執行環境是否有覆蓋該變數。

4. **不使用 URL 作為 Express 路徑：** 回顧程式設計意圖，如果 `DEBUG_URL` 代表一個完整後端服務的 URL（含協議與主機），那麼它不應該出現在 `app.use` 或 `app.get` 的路徑參數中。這種變數應僅用於組裝對外連結或在前端使用（例如 LINE LIFF 的 webhook 或 OAuth 回調URL）。在後端代碼中，**使用 URL 請求外部服務時，請改用 HTTP 請求庫**（如 axios 在 `test-system.ts` 中的用法【57†】），或使用反向代理中介，而不是試圖讓 Express 直接偵聽一個包含協議的路徑。

5. **測試與驗證：** 應用上述更改後，重新啟動伺服器並觀察日誌。正確的情況下，伺服器應能正常啟動而無 `path-to-regexp` 錯誤。此時可透過訪問已定義的路由（例如健康檢查路由 `/health`）確認其功能。也建議運行系統診斷 (`src/test-system.ts`) 來確保環境變數與路由皆正常。經修正後，`curl http://localhost:5000/health` 應該返回預期結果而不再拋出錯誤。

透過以上調整，即可根除 **Missing parameter name at 7: \${DEBUG\_URL}** 錯誤。總而言之，**保持路由定義語法合法、避免在路徑字串中殘留模板變數**，並謹慎處理環境變數的載入與使用，是確保 Express 應用穩定運行的關鍵。若有需要將請求轉發或處理外部URL，應使用適當的代理或請求方案，而非直接擴充路由字串。這些修正將提升程式健壯性，避免類似錯誤再次發生。

**來源：** 專案原始碼及相關環境設定檔案分析。
